#! /usr/bin/perl

use strict;
use warnings;
use DBI;
use Getopt::Long;

my ($mysql_host, $mysql_port, $mysql_socket);

GetOptions(
    "host=s"   => \$mysql_host,
    "port=i"   => \$mysql_port,
    "socket=s" => \$mysql_socket,
) or exit(1);

if (@ARGV < 1) {
    die "Usage: $0 [options] dbname table1 table2 ...\n";
}

my $dbname = shift @ARGV;

# connect
my $dbh = do {
    my $dsn = "DBI:mysql:database=$dbname;user=root";
    $dsn .= ";host=$mysql_host"
        if $mysql_host;
    $dsn .= ";port=$mysql_port"
        if $mysql_port;
    $dsn .= ";mysql_socket=$mysql_socket"
        if $mysql_socket;
    DBI->connect($dsn)
        or die "failed to connect to $dsn:" . $DBI::errstr;
};

my @triggers = (
    "drop procedure if exists myfuku_begin",
    <<'EOT',
create procedure myfuku_begin()
begin
  insert into myfuku_log (action) values ('');
  set @myfuku_id=@@last_insert_id;
  select trx_id into @myfuku_trx_id from information_schema.innodb_trx where trx_mysql_thread_id=connection_id();
end
EOT
    "drop function if exists myfuku_encode_string",
    <<'EOT',
create function myfuku_encode_string(src longtext) returns longtext deterministic
begin
  return concat('["',replace(to_base64(src),'\\n',''),'"]');
end
EOT
);

# get schema of the table
while (@ARGV) {
    my $tblname = shift;
    # fetch the list of columns
    my $rows = $dbh->selectall_arrayref('select * from INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA=? and TABLE_NAME=?', { Slice => {} }, $dbname, $tblname)
        or die $dbh->errstr;
    # functions
    my $checkexpr = q{@myfuku_trx_id is not null and (select count(*) from information_schema.innodb_trx where trx_id=@myfuku_trx_id and trx_mysql_thread_id=connection_id()) = 1};
    my $build_row_args = sub {
        my $prefix = shift;
        my @args;
        for my $col (@$rows) {
            push @args, qq{',"$col->{COLUMN_NAME}":'};
            if ($col->{DATA_TYPE} =~ m{(?:integer|int|real)(\s?|$)}) {
                push @args, qq{concat('"',$prefix.$col->{COLUMN_NAME},'"')};
            } else {
                push @args, qq{myfuku_encode_string($prefix.$col->{COLUMN_NAME})};
            }
        }
        return +(qq{'{}'})
            unless @args;
        $args[0] =~ s|^',|'{|s;
        push @args, q|'}'|;
        @args;
    };
    # create insert trigger
    push @triggers, "drop trigger if exists myfuku_${tblname}_after_insert";
    push @triggers, <<"EOT";
create trigger myfuku_${tblname}_after_insert after insert on $tblname
for each row begin
  if $checkexpr then
    update myfuku_log set action=concat(action,',',concat('["insert","$tblname",',@{[join ',', $build_row_args->('new')]},']')) where id=\@myfuku_id;
  end if;
end
EOT
    # create update trigger
    push @triggers, "drop trigger if exists myfuku_${tblname}_after_update";
    push @triggers, <<"EOT";
create trigger myfuku_${tblname}_after_update after update on $tblname
for each row begin
  if $checkexpr then
    update myfuku_log set action=concat(action,',',concat('["update","$tblname",',@{[join ',', $build_row_args->('new')]},',',@{[join ',', $build_row_args->('old')]},']')) where id=\@myfuku_id;
  end if;
end
EOT
    # create delete trigger
    push @triggers, "drop trigger if exists myfuku_${tblname}_after_delete";
    push @triggers, <<"EOT";
create trigger myfuku_${tblname}_after_delete after delete on $tblname
for each row begin
  if $checkexpr then
    update myfuku_log set action=concat(action,',',concat('["delete","$tblname",',@{[join ',', $build_row_args->('old')]},']')) where id=\@myfuku_id;
  end if;
end
EOT
}

chomp $_ for @triggers;

print "delimiter |\n";
print "$_|\n" for @triggers;
print "delimiter ;\n";
